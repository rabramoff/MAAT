################################
#
# Canopy system functions
#
# AWalker February 2018
#
################################

source('../../functions/solver_tridiag.R') 



# Big Leaf canopy scaling
###############################

# Sellers et al 1992
f_sys_bigleaf_s1992 <- function(., k=.super$state_pars$k_dirprime, ... ) {
  # this function was described in Sellers to deal with time intergrated values of fpar and k
  # could write wrapper function or if to pass different k coefficients
  # APW: why is k an argument? Assuming in case k_dir want to be used, but how woulÂ§d that occur?

  # calculate fPAR, after Sellers 1992, see also Friend 2001
  fpar <- 1 - exp(-k*.super$env$lai)

  # set leaf environment
  # absorbed light in leaf layer 0 - F_0 * first half of B_2 in Eq 37b (Sellers 1992)
  # APW: same as beerslaw RT function when l = 0
  .super$leaf$env$par[] <- (1-.super$state_pars$lscattering)*.super$state_pars$k_dir * .super$env$par
  # assume no variation in CO2 concentration, VPD, and T
  #.super$leaf$env$ca_conc <- .super$env$ca_conc
  #.super$leaf$env$vpd     <- .super$env$vpd
  #.super$leaf$env$temp    <- .super$env$temp

  # set leaf N0 or Vcmax0 - as with multi-layer model need to choose one and initialise leaf fnames correctly
#  .super$leaf$state$leafN_area[] <- .super$state$totalN * k / fpar
#  .super$leaf$pars$atref$vcmax[] <- .super$pars$vcmax0 
#  if(.super$fnames$scale_vcmax=='f_scale_two_layer') {
#    .super$leaf$pars$atref$jmax[] <- .$scale_jmax(1, var='jmax' )
#    .super$leaf$pars$f[]          <- .$scale_f(1,    var='f' )
#    .super$leaf$pars$g1_medlyn[]  <- .$scale_g1(1,   var='g1' )
#  }  
  .super$leaf$pars$atref$vcmax[] <- .super$pars$vcmax$layer0 
  # APW: is this really necessary? Sets values for leaf, but using layer1, not layer0
  if(.super$fnames$scale$vcmax=='f_scale_two_layer') {
    .super$leaf$pars$atref$vcmax[] <- .$scale.vcmax(1, var='vcmax' )
    .super$leaf$pars$atref$jmax[]  <- .$scale.jmax(1, var='jmax' )
    .super$leaf$pars$f[]           <- .$scale.f(1, var='f' )
    .super$leaf$pars$g1_medlyn[]   <- .$scale.g1(1, var='g1' )
  }  

  # calculate A0
  # leaf model will calculate Vcmax0 and Jmax0 according to leaf process specifications, e.g. from N0, temp, etc
  .super$leaf$run()

  # print leaf state
  if(.$cpars$verbose) {
    print('', quote=F )
    print('Bigleaf leaf pars:', quote=F )
    print(.super$leaf$fnames$etrans)
    print(.super$leaf$pars$theta_j)
    print(.super$leaf$pars$g1_medlyn)
    print(.super$leaf$pars$f)
    print(.super$leaf$pars$atref)
    print(.super$leaf$state_pars)
  }

  # scale
  .super$state$integrated$apar <- fpar * .super$env$par
  # Eq 34 Sellers (1992)
  .super$state$integrated$A              <- .super$leaf$state$A * fpar/k
  .super$state$integrated$rd             <- .super$leaf$state$rd * fpar/k
  .super$state$integrated$Acg_lim        <- if(.super$leaf$state$lim==2) .super$state$integrated$A else 0
  .super$state$integrated$Ajg_lim        <- if(.super$leaf$state$lim==3) .super$state$integrated$A else 0
  .super$state$integrated$Apg_lim        <- if(.super$leaf$state$lim==7) .super$state$integrated$A else 0
  .super$state$integrated$layers_Acg_lim <- if(.super$leaf$state$lim==2) .super$env$lai
  .super$state$integrated$layers_Ajg_lim <- if(.super$leaf$state$lim==3) .super$env$lai
  .super$state$integrated$layers_Apg_lim <- if(.super$leaf$state$lim==7) .super$env$lai
  # convert reistance to conductance, minus minimum conductance, scale, add min conductance multiplied by LAI
  # A combination of Eq 35 and Eq 37f in Sellers (1992)
  .super$state$integrated$gs             <- (1/.super$leaf$state_pars$rs - .super$leaf$pars$g0) * fpar/k + .super$leaf$pars$g0*.super$env$lai 
  # canopy mean values of Ci and Cc - not sure this is correct
  .super$state$integrated$ci             <- .super$leaf$state$ci * fpar/k / .super$env$lai
  .super$state$integrated$cc             <- .super$leaf$state$cc * fpar/k / .super$env$lai
  .super$state$integrated$cb             <- .super$leaf$state$cb * fpar/k / .super$env$lai
}



# Two Big Leaf canopy scaling
###############################
# - accounts for direct and diffuse light separately but only calculates A once for each radiation type
f_sys_2bigleaf <- function(.) {
  # Thornton calculates the mean of all these canopy values, what does Dai do?

  # calculate LAIsun and LAIshade - Dai 2004
  Lsun   <- (1 - exp(-.super$state_pars$k_dir*.super$env$lai)) / .super$state_pars$k_dir
  Lshade <- .super$env$lai - Lsun

  # calculate APARsun and APARshade
  # APARshade is the scattered part of the direct beam plus diffuse radiation
  .$rt(1:.super$env$lai)
  #take the mean of these? - need to check, is there an analytical method?

  # Leaf environment
  #.super$leaf$env$ca_conc <- .super$env$ca_conc
  #.super$leaf$env$vpd     <- .super$env$vpd

  # calculate Nsun and Nshade - this doesn't really make sense as leaf N is not able to vary on the time scales that on which sun and shade leaves vary
  .super$leaf$state$leafN_area <- .super$state$totalN * k / fpar

  # calculate Asun and Ashade

  # scale & combine
}



# Multilayer canopy scaling
###############################
f_sys_multilayer <- function(.) {

  # initialise layers
  # APW: Norman scheme calculate layers + 1 to include soil 
  # k_layer determines where in the layer photosynthesis etc is calculated, a value of 0.5 calculates at the center of the layer
  linc           <- .super$env$lai / .super$pars$layers
  ca_calc_points <- seq((linc-linc*.super$pars$k_layer), (.super$env$lai-linc*.super$pars$k_layer), linc )
  layers         <- .super$pars$layers # this could be a function to dynamically specify the no. of layers
  # APW: consider putting this function in fns to avoid needing to use .super and .=.super
  .super$init_vert(.=.super, l=layers ) # reallocating this memory is unnecessary in cases where layers is a fixed parameter.
  #print(ca_calc_points)

  # canopy leaf layer parameters
#  .super$state$vert$leaf$leaf.leafN_area[]  <- .$scale_n(ca_calc_points)
#  .super$state$vert$leaf$leaf.atref.vcmax[] <- .$scale_vcmax(ca_calc_points, var='vcmax' )
#  leaf_vars <- c('leaf.leafN_area', 'leaf.atref.vcmax' )
#  if(.super$fnames$scale_vcmax=='f_scale_two_layer') {
#    .super$state$vert$leaf$leaf.atref.jmax[] <- .$scale_jmax(ca_calc_points, var='jmax' )
#    .super$state$vert$leaf$leaf.f[]          <- .$scale_f(ca_calc_points, var='f' )
#    .super$state$vert$leaf$leaf.g1_medlyn[]  <- .$scale_g1(ca_calc_points, var='g1' )
#    leaf_vars <- c(leaf_vars, 'leaf.atref.jmax', 'leaf.f', 'leaf.g1_medlyn' )
#  }  
#  #print(.super$state$vert$leaf)
#
#  # canopy leaf layer environment
#  .super$state$vert$leaf$leaf.ca_conc[]     <- .$scale_ca(ca_calc_points)
#  .super$state$vert$leaf$leaf.vpd[]         <- .$scale_vpd(ca_calc_points)
#  leaf_vars <- c(leaf_vars, 'leaf.ca_conc', 'leaf.vpd', 'leaf.par' )
  .super$state$vert$leaf$leaf.leafN_area[]   <- .$scale.n(ca_calc_points, var='n' )
  #.super$state$vert$leaf$leaf.atref.vcmax[]  <- .[['scale.vcmax']](l=ca_calc_points, var='vcmax' )
  .super$state$vert$leaf$leaf.atref.vcmax[]  <- .$scale.vcmax(ca_calc_points, var='vcmax' )
  leaf_vars <- c('leaf.leafN_area', 'leaf.atref.vcmax' )
  if(.super$fnames$scale$vcmax=='f_scale_two_layer') {
    .super$state$vert$leaf$leaf.atref.jmax[] <- .$scale.jmax(ca_calc_points, var='jmax' )
    .super$state$vert$leaf$leaf.f[]          <- .$scale.f(ca_calc_points, var='f' )
    .super$state$vert$leaf$leaf.g1_medlyn[]  <- .$scale.g1(ca_calc_points, var='g1' )
    leaf_vars <- c(leaf_vars, 'leaf.atref.jmax', 'leaf.f', 'leaf.g1_medlyn' )
  }  

  # canopy leaf layer environment
  # APW: when called as a character string for some reason the proto . is not fully recognised within the function
  #      parameters can be found, but aliased function calls fail, maybe named function calls work
  .super$state$vert$leaf$leaf.ca_conc[]      <- .$scale.ca_conc(ca_calc_points, var='ca_conc', vlist='env' )
  .super$state$vert$leaf$leaf.vpd[]          <- .$scale.vpd(ca_calc_points, var='vpd', vlist='env' )
  leaf_vars <- c(leaf_vars, 'leaf.ca_conc', 'leaf.vpd', 'leaf.par' )
  #print(.super$state$vert$leaf)

  # Light scaling
  .$rt(ca_calc_points)

  # sunlit leaves / direct light
  .super$state$vert$leaf$leaf.par[] <- .super$state$vert$sun$apar
  # create leaf environment  matrix
  lmatrix  <- vapply(.super$state$vert$leaf[leaf_vars], function(v) v, numeric(layers) )
  # run leaf
  leaf_out <- vapply(1:layers, .$run_leaf, .super$leaf$output(), df=lmatrix )
  # assign data to canopy object data structure
  for(vname in row.names(leaf_out)) .super$state$vert$sun[[vname]][] <- leaf_out[vname,]
  if(.$cpars$verbose) {
    print('', quote=F )
    print('Sun leaves:', quote=F )
    print(lmatrix)
    print(leaf_out)
    print(.super$state$vert$sun)
  }

  # shade leaves
  if(any(.super$state$vert$sun$fraction < 1) ) {
    .super$state$vert$leaf$leaf.par[] <- .super$state$vert$shade$apar
    # create leaf environment matrix
    lmatrix  <- vapply(.super$state$vert$leaf[leaf_vars], function(v) v, numeric(layers) )
    # run leaf
    leaf_out <- vapply(1:layers, .$run_leaf, .super$leaf$output(), df=lmatrix )
    # assign data to canopy object data structure
    for(vname in row.names(leaf_out)) .super$state$vert$shade[[vname]][] <- leaf_out[vname,]
    if(.$cpars$verbose) {
      print('', quote=F )
      print('Shade leaves:', quote=F )
      print(lmatrix)
      print(leaf_out)
      print(.super$state$vert$shade)
    }
  }

  # combine sun and shade leaves
  for(vname in c('apar','A','gb','gs','gi','g','rd','cb','ci','cc') ) {
    .super$state$vert$layer[[vname]][] <-
      .super$state$vert$sun[[vname]] * .super$state$vert$sun$fraction + .super$state$vert$shade[[vname]] * .super$state$vert$shade$fraction
  }
  # partition A among limiting rates
  .super$state$vert$layer$Acg_lim[] <-
    .super$state$vert$sun$A * (.super$state$vert$sun$lim==2) * .super$state$vert$sun$fraction +
    .super$state$vert$shade$A * (.super$state$vert$shade$lim==2) * .super$state$vert$shade$fraction
  .super$state$vert$layer$Ajg_lim[] <- 
    .super$state$vert$sun$A * (.super$state$vert$sun$lim==3) * .super$state$vert$sun$fraction + 
    .super$state$vert$shade$A * (.super$state$vert$shade$lim==3) * .super$state$vert$shade$fraction
  .super$state$vert$layer$Apg_lim[] <- 
    .super$state$vert$sun$A * (.super$state$vert$sun$lim==7) * .super$state$vert$sun$fraction + 
    .super$state$vert$shade$A * (.super$state$vert$shade$lim==7) * .super$state$vert$shade$fraction
  if(.$cpars$verbose) {
    print('', quote=F )
    print('Layer:', quote=F )
    print(.super$state$vert$layer)
    print(.super$state$vert$sun['lim'])
    print(.super$state$vert$shade['lim'])
  }

  # integrate canopy layers
  # canopy sum values
  for(vname in c('apar','A','gb','gs','gi','g','rd','Acg_lim','Ajg_lim','Apg_lim') ) {
    .super$state$integrated[[vname]][] <- sum(.super$state$vert$layer[[vname]]) * linc
  }
  # canopy mean values - not sure that this is correct
  .super$state$integrated$cc[] <- sum(.super$state$vert$layer$cc) * linc / .super$env$lai
  .super$state$integrated$ci[] <- sum(.super$state$vert$layer$ci) * linc / .super$env$lai
  .super$state$integrated$cb[] <- sum(.super$state$vert$layer$cb) * linc / .super$env$lai

}



### END ###
